# let, const, and Block Scoping in JavaScript (ES6)

## let Keyword

- `let` is used to declare variables.
- Variables declared with `let` are **not hoisted** like `var`. Accessing them before declaration results in a **ReferenceError**.
- `let` provides **block scoping**: variables are only accessible within the block (`{}`) they are declared in.
- Example:
  ```js
  console.log(productId); // ReferenceError
  let productId = 12;
  ```

## const Keyword

- `const` is used to declare **constants** (variables that cannot be reassigned).
- Must be **initialized at the time of declaration**.
- Also block scoped.
- Example:
  ```js
  const MARKET_PERCENT = 100;
  MARKET_PERCENT = 10; // TypeError: Assignment to constant variable.
  ```

## Block Scoping

- Variables declared with `let` or `const` inside a block are not accessible outside that block.
- Example:
  ```js
  let productId = 12;
  {
    let productId = 2000;
    console.log(productId); // 2000
  }
  console.log(productId); // 12
  ```

## Temporal Dead Zone

- The period between entering scope and variable declaration is called the **temporal dead zone**.
- Accessing a `let` or `const` variable in this zone throws a ReferenceError.

## let vs var in Loops and Closures

- Using `var` in a loop can cause closures to capture the final value of the variable.
- Using `let` ensures each iteration gets its own scoped variable.
- Example:
  ```js
  var updateFunctions = [];
  for (let i = 0; i < 2; i++) {
    updateFunctions.push(function() { return i; });
  }
  console.log(updateFunctions[0]()); // 0
  ```

## Summary Table

| Keyword | Hoisted | Scope      | Reassignable | Must Initialize |
|---------|---------|------------|--------------|----------------|
| var     | Yes     | Function   | Yes          | No             |
| let     | No      | Block      | Yes          | No             |
| const   | No      | Block      | No           | Yes            |

**Best Practice:**  
Use `let` and `const` instead of `var` to avoid hoisting issues and to take advantage of block scoping.