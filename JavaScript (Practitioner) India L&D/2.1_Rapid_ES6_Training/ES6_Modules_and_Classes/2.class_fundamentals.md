# ES6 Class Fundamentals

ES6 introduces the `class` keyword, providing a cleaner syntax for working with prototypes and constructor functions.

## Basic Class Declaration

```js
class Task {}
console.log(typeof Task); // "function"
```
- Classes are just special functions under the hood.

## Instantiating Classes

```js
let task = new Task();
console.log(typeof task); // "object"
console.log(task instanceof Task); // true
```

## Adding Methods

```js
class Task {
  showId() {
    return 99;
  }
}
let task = new Task();
console.log(task.showId()); // 99
```
- Methods use shorthand syntax (no `function` keyword).

## Methods and Prototypes

```js
console.log(task.showId === Task.prototype.showId); // true
```
- Methods are added to the prototype, just like with constructor functions in ES5.

## Constructors

```js
class Task {
  constructor() {
    console.log("constructing task");
  }
}
let task = new Task(); // "constructing task"
```
- The `constructor` method is called when a new instance is created.

## Syntax Differences

- **No commas** between methods in a class body (unlike object literals).
- Declaring variables directly inside the class body (outside methods) is a syntax error in ES6 (class fields are added in later versions).

## Hoisting

- Classes are **not hoisted**. You must declare a class before using it.

```js
let task = new Task(); // Error: Cannot access 'Task' before initialization
class Task {}
```

## Classes as Expressions

```js
let NewClass = class {
  constructor() {
    console.log("constructing task");
  }
};
let obj = new NewClass(); // "constructing task"
```
- Classes can be assigned to variables and used in expressions.

## Differences from Constructor Functions

- Constructor functions can be called with `.call()` to set `this`:
  ```js
  function Task() {
    console.log("constructing task");
  }
  Task.call({}); // "constructing task"
  ```
- **Classes cannot be called with `.call()` or without `new`**:
  ```js
  class Task {
    constructor() {
      console.log("constructing task");
    }
  }
  Task.call({}); // Error: Class constructor cannot be invoked without 'new'
  ```

## Global Namespace

- Constructor functions are added to the global object (e.g., `window` in browsers).
- Classes are **not** added to the global object.

```js
function Project() {}
console.log(window.Project === Project); // true

class Task {}
console.log(window.Task === Task); // false
```

## Summary

- ES6 classes provide a cleaner, more familiar syntax for OOP.
- Classes are not hoisted, not global, and cannot be called without `new`.
- Methods are added to the prototype, just like ES5